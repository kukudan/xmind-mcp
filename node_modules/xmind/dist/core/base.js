"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const TreeModel = require("tree-model");
const common_1 = require("../utils/common");
const v4 = require('uuid/v4');
const Debug = require('debug');
const DEFAULT_DEBUG_SCOPE = 'xmind-sdk';
class Base {
    /* istanbul ignore next */
    constructor(options = {}) {
        this.options = options;
        this.tree = new TreeModel();
        this.options = options;
        this._debug = Debug(this.options.debug || DEFAULT_DEBUG_SCOPE);
    }
    isValidComponentId(componentId) {
        if (!componentId || typeof componentId !== 'string') {
            return false;
        }
        const node = this.rootNode.first((node) => node.model.id === componentId);
        return !!node;
    }
    setRoot(options) {
        this.rootNode = this.tree.parse(Object.assign(options, { children: [] }));
        return this;
    }
    destroyNode(options) {
        const node = this.rootNode.first((node) => {
            return node.model.id === options.id;
        });
        node.drop();
        return true;
    }
    addChildNode(options) {
        const node = this.rootNode.first((node) => {
            return node.model.id === options.parentId;
        });
        node.addChild(this.tree.parse(options));
    }
    exist(componentId) {
        const n = this.rootNode.first((node) => {
            return node.model.id === componentId;
        });
        return !!n;
    }
    findComponentIdBy(title) {
        const n = this.rootNode.first((node) => {
            return node.model.title === title;
        });
        if (!n)
            return null;
        return n.model.id;
    }
    all() {
        const nodes = this.rootNode.all(() => true);
        const map = {};
        nodes.forEach(node => {
            map[String(node.model.id)] = node.model.title;
        });
        return map;
    }
    /**
     *
     * @param { ConflictedOnDifferentBranchOptions | ConflictedOnSameBranchOptions } options
     * @return { String | Null }
     */
    getConflictedComponentId(options) {
        const validString = common_1.isString(options.title);
        if (validString && options.parentId) {
            return this.different(options);
        }
        if (validString && options.customId) {
            return this.identical(options);
        }
        return null;
    }
    /**
     * @description Print debug information
     * @param {Array} args - the rest arguments
     */
    debug(...args) {
        this._debug(...args);
    }
    /**
     * @description uuid/v4
     */
    get id() {
        return v4();
    }
    different(options) {
        const finder = (node) => {
            return node.model.title === options.title;
        };
        for (const node of this.rootNode.all(finder)) {
            if (node.parent.model.id === options.parentId) {
                return node.model.id;
            }
        }
        return null;
    }
    identical(options) {
        const finder = (node) => {
            return node.model.title === options.title &&
                node.model.customId === options.customId;
        };
        const nodes = this.rootNode.all(finder);
        if (nodes.length <= 0) {
            return null;
        }
        return nodes[0].model.id;
    }
}
exports.default = Base;
//# sourceMappingURL=base.js.map