/// <reference types="node" />
import { EventEmitter } from 'events';
declare type OperateType = 'undo' | 'redo' | 'custom';
declare const EXECUTOR_RESULT_NEXT = "next";
declare const EXECUTOR_RESULT_BREAK = "break";
declare type ExecutorResult = (typeof EXECUTOR_RESULT_NEXT) | (typeof EXECUTOR_RESULT_BREAK);
export interface Task {
    type?: any;
    undo?(): any;
    redo?(): any;
}
declare class Group {
    private _identifier;
    private _executor;
    private _tasks;
    constructor(identifier: string, executor?: Function);
    getName(): string;
    push(task: Task): void;
    pop(): void;
    execute(operateType: OperateType): ExecutorResult;
}
interface UndoManagerOption {
    limit?: number;
}
declare class UndoManager extends EventEmitter {
    private _undoStack;
    private _redoStack;
    private _standbyGroup;
    private _limitedLength;
    private _canRecord;
    private _blocking;
    private _allInOne;
    private _nameToTagGroup;
    private TIMEOUT_ID;
    constructor(options?: UndoManagerOption);
    setRecordState(canRecord: boolean): void;
    keepAllInOne(allInOne: boolean): void;
    setStackLimitedLength(length: number): void;
    _genNewGroup(name: string, executor?: Function): Group;
    _autoStandbyGroup(): Group;
    add(task: Task, type?: any): void;
    push(task: Task, type?: any): void;
    pop(): Group;
    /**
     * Append to last group which is not tag group
     * @param {*} task
     * @param {*} type
     */
    append(task: Task, type: any): void;
    getLastGroup(): Group;
    isTagGroup(group: Group): boolean;
    pushTag(tagName: string, executor?: Function): void;
    popTag(tagName: string): Group;
    undo(): void;
    redo(): void;
    _resetStandbyGroup(): void;
    _changeUndoStack(group?: Group): Group;
    isExecuting(): boolean;
    canUndo(): boolean;
    canRedo(): boolean;
    clearRedo(): void;
    getIndex(): number;
}
export default UndoManager;
