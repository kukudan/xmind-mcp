"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * distance between two point.
 */
function getPointDistance(p1, p2) {
    return Math.hypot(p1.x - p2.x, p1.y - p2.y);
}
exports.getPointDistance = getPointDistance;
/**
 * Rotate point/vector around origin({x:0,y:0}).
 * @param  {number} radian 弧度值，正为顺时针，负为逆时针. （在标准笛卡尔坐标系中，正度数指的是x正轴逆时针旋转，但我们的坐标系是上下颠倒的）
 */
function rotatePoint(point, radian) {
    let sinA = Math.sin(radian);
    let cosA = Math.cos(radian);
    let x = point.x * cosA - point.y * sinA;
    let y = point.x * sinA + point.y * cosA;
    return { x, y };
}
exports.rotatePoint = rotatePoint;
function rotatePointDeg(point, degree) {
    return rotatePoint(point, degree2Radian(degree));
}
exports.rotatePointDeg = rotatePointDeg;
/**
 * 计算出 以center为旋转中心，将point旋转radian度后的点
 * @param radian {number} 是弧度值(带PI的），正为顺时针，负为逆时针
 */
function rotatePointAround(point, center, radian) {
    let v = {
        x: point.x - center.x,
        y: point.y - center.y
    };
    v = rotatePoint(v, radian);
    return {
        x: center.x + v.x,
        y: center.y + v.y
    };
}
exports.rotatePointAround = rotatePointAround;
function rotatePointAroundDeg(point, center, degree) {
    return rotatePointAround(point, center, degree2Radian(degree));
}
exports.rotatePointAroundDeg = rotatePointAroundDeg;
function degree2Radian(degree) {
    return degree / 180 * Math.PI;
}
exports.degree2Radian = degree2Radian;
//使一个向量长度标准化为1，也可标准化为别的长度。
function normalizeVector(vector, len = 1) {
    const d = Math.hypot(vector.x, vector.y);
    const ratio = d / len;
    return {
        x: vector.x / ratio,
        y: vector.y / ratio
    };
}
exports.normalizeVector = normalizeVector;
//construct a vector from two point.
function diffPoint(from, to) {
    return {
        x: to.x - from.x,
        y: to.y - from.y
    };
}
exports.diffPoint = diffPoint;
function addPoint(pointA, pointB) {
    return {
        x: pointA.x + pointB.x,
        y: pointA.y + pointB.y
    };
}
exports.addPoint = addPoint;
function isEqualPoint(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}
exports.isEqualPoint = isEqualPoint;
function isPointLike(pos) {
    return !!pos && typeof pos.x === 'number' && typeof pos.y === 'number';
}
exports.isPointLike = isPointLike;
/**
 * @description 判断某个点是否在多边形内部
 * @param {point} point
 * @param {Array.<point>} polygonPoints 多边形的构成点
 * @return {boolean}
 * */
function isPointInPolygon(point, polygonPoints) {
    // todo 这一块儿的运算逻辑需要学习一下
    let i, j = polygonPoints.length - 1;
    let oddNodes = false;
    let x = point.x, y = point.y;
    let iPoint, jPoint;
    for (i = 0; i < polygonPoints.length; i++) {
        iPoint = polygonPoints[i];
        jPoint = polygonPoints[j];
        if ((iPoint.y < y && jPoint.y >= y
            || jPoint.y < y && iPoint.y >= y)
            && (iPoint.x <= x || jPoint.x <= x)) {
            if (iPoint.x + (y - iPoint.y) / (jPoint.y - iPoint.y) * (jPoint.x - iPoint.x) < x) {
                oddNodes = !oddNodes;
            }
        }
        j = i;
    }
    return oddNodes;
}
exports.isPointInPolygon = isPointInPolygon;
/**
 * @description 凸包算法
 * @return {Point[]}
 * */
function convexPointHull(pointList) {
    pointList = [...pointList];
    pointList.sort((a, b) => a.x !== b.x ? a.x - b.x : a.y - b.y);
    const n = pointList.length;
    const hull = [];
    for (let i = 0; i < 2 * n; i++) {
        const j = i < n ? i : 2 * n - 1 - i;
        while (hull.length >= 2 && removeMiddle(hull[hull.length - 2], hull[hull.length - 1], pointList[j]))
            hull.pop();
        hull.push(pointList[j]);
    }
    hull.pop();
    return hull;
    function removeMiddle(a, b, c) {
        const cross = (a.x - b.x) * (c.y - b.y) - (a.y - b.y) * (c.x - b.x);
        const dot = (a.x - b.x) * (c.x - b.x) + (a.y - b.y) * (c.y - b.y);
        return cross < 0 || cross === 0 && dot <= 0;
    }
}
exports.convexPointHull = convexPointHull;
function Point(x, y) {
    return { x, y };
}
exports.Point = Point;
//# sourceMappingURL=point.js.map