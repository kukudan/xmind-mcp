"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const number_1 = require("./number");
const point_1 = require("./point");
function isBoundsEqual(bound1, bound2) {
    return (bound1.x === bound2.x &&
        bound1.y === bound2.y && isSameSize(bound1, bound2));
}
exports.isBoundsEqual = isBoundsEqual;
function isBoundsIntersect(bounds1, bounds2) {
    return !(bounds2.x > bounds1.x + bounds1.width ||
        bounds1.x > bounds2.x + bounds2.width ||
        bounds2.y > bounds1.y + bounds1.height ||
        bounds1.y > bounds2.y + bounds2.height);
}
exports.isBoundsIntersect = isBoundsIntersect;
function isBoundsContainPoint(bound, point) {
    return !(point.x < bound.x ||
        point.x > bound.x + bound.width ||
        point.y < bound.y ||
        point.y > bound.y + bound.height);
}
exports.isBoundsContainPoint = isBoundsContainPoint;
function mergeBounds(bound1, bound2) {
    const x = Math.min(bound1.x, bound2.x);
    const y = Math.min(bound1.y, bound2.y);
    const width = Math.max(bound1.x + bound1.width, bound2.x + bound2.width) - x;
    const height = Math.max(bound1.y + bound1.height, bound2.y + bound2.height) - y;
    return {
        x, y, width, height
    };
}
exports.mergeBounds = mergeBounds;
function mergeBoundsArr(boundsArr) {
    if (!Array.isArray(boundsArr))
        throw 'Wrong arguments';
    if (boundsArr.length === 0)
        return { x: 0, y: 0, width: 0, height: 0 };
    if (boundsArr.length === 1)
        return boundsArr[0];
    return boundsArr.reduce((pre, cur) => mergeBounds(pre, cur));
}
exports.mergeBoundsArr = mergeBoundsArr;
function inflateBounds(bounds, padding) {
    return {
        x: bounds.x - padding,
        y: bounds.y - padding,
        width: bounds.width + padding * 2,
        height: bounds.height + padding * 2
    };
}
exports.inflateBounds = inflateBounds;
function moveBounds(bounds, vector) {
    return {
        x: vector.x + bounds.x,
        y: vector.y + bounds.y,
        width: bounds.width,
        height: bounds.height
    };
}
exports.moveBounds = moveBounds;
function fromPoints(pointArr) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    pointArr.forEach(point => {
        if (point.x < minX) {
            minX = point.x;
        }
        if (point.x > maxX) {
            maxX = point.x;
        }
        if (point.y < minY) {
            minY = point.y;
        }
        if (point.y > maxY) {
            maxY = point.y;
        }
    });
    return {
        x: minX,
        y: minY,
        height: maxY - minY,
        width: maxX - minX
    };
}
exports.fromPoints = fromPoints;
function rotateBounds(bound, degree, cx = 0, cy = 0) {
    let p1 = { x: bound.x, y: bound.y }, p2 = { x: bound.x + bound.width, y: bound.y }, p3 = { x: bound.x + bound.width, y: bound.y + bound.height }, p4 = { x: bound.x, y: bound.y + bound.height };
    return fromPoints([p1, p2, p3, p4].map(p => point_1.rotatePointAroundDeg(p, { x: cx, y: cy }, degree)));
}
exports.rotateBounds = rotateBounds;
function outBounds(bounds, biggerBounds) {
    const newBounds = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    };
    if (bounds.x < biggerBounds.x) {
        newBounds.x = bounds.x;
        newBounds.width = bounds.x - biggerBounds.x;
    }
    else if (bounds.x + bounds.width > biggerBounds.x + biggerBounds.width) {
        newBounds.x = biggerBounds.x;
        newBounds.width = bounds.x + bounds.width - (biggerBounds.x + biggerBounds.width);
    }
    if (bounds.y < biggerBounds.y) {
        newBounds.y = bounds.y;
        newBounds.height = bounds.y - biggerBounds.y;
    }
    else if (bounds.y + bounds.height > biggerBounds.y + biggerBounds.height) {
        newBounds.y = biggerBounds.y;
        newBounds.height = bounds.y + bounds.height - (biggerBounds.y + biggerBounds.height);
    }
    return newBounds;
}
exports.outBounds = outBounds;
function isSameSize(size1, size2) {
    return number_1.stripNum(size1.width) === number_1.stripNum(size2.width) &&
        number_1.stripNum(size1.height) === number_1.stripNum(size2.height);
}
exports.isSameSize = isSameSize;
//# sourceMappingURL=bounds.js.map